/*
    线程（操作系统层面的多任务）
	（抢占式）多任务处理，由操作系统，调度分配cup资源，上下文切换频繁，资源开销比较高

协程 Coroutine
	轻量级“线程”
	(非抢占式)多任务处理，由协程主动交出控制权。资源开销比较低
	编译器/解释器/虚拟机层面的多任务 （非操作系统层面的多任务）使用go语言内部调度器，来管理资源
		编译器会把我们go一个func 来解释成一个协程，具体到执行上呢，
		我们go语言后面会有一个调度器，来调度我们的协程
	多个协程可能在一个或多个线程上运行，这个是由调度器决定的，
	他可以说我们都在一个线程上运行，也可以在多个线程上运行
Coroutines
子程序是协程的一个特例，
（所有的 函数调用 都可看成一个子程序，
也就是说所有的 函数调用 都是协程一个特例，
协程是一个比子程序更加宽泛的概念）

普通函数vs协程
普通函数：
[线程 main()->doWork()]
在一个线程内，有一个main函数，main函数去调用一个doWork函数；等doWork做完以后，才把控制权交还给main，然后main函数去执行下一个语句
协程：
[线程+ main()<->doWork() ]
在一个或多个线程中，man和doWork之间不是单向的，而是有一个双向的通道。
man和doWork之间的数据和控制权可以双向的流通，就相当于我们 并发执行的 两个线程，
man和doWork之间 就像两个人 互相各做各的事情。中间可以用互相通信的通道 还能去互相的通信

goroutine
{进程 [调度器] 【线程(goroutine)】【线程 (goroutine)(goroutine)】【线程 (goroutine)(goroutine)(goroutine)...】}
go语言程序开出来一个进程，（进程就是一段运行中的程序，是操作系统进行资源分配/调度的最小单位）
进程下面会有一个调度器，这个调度器负责调度协程，
协程是怎样调度的呢，有些协程它可能会放到一个线程里面，有些可能两个放在一个线程里面；或者呢很多个协程放在一个线程里面。
到底是谁和谁放到一个线程里，谁和谁分开，这个不用我们管。那是调度器来控制的。
goroutine的定义
任何函数只需加上go关键字，就能送给调度器运行，就变成了一个协程
不需要在定义时区分是否是异步函数
调度器会在合适的点进行切换
使用go run -race filename 来检测数据访问冲突

goroutine 可能的切换点
I/O select
channel
等待锁
函数调用（可能）
runtime.Gosched()
以上只是参考，不能保证切换，不能保证在其它地方不切换

*/
package main

import (
	"fmt"
	"time"
)

func main() {
	// 定义一个长度为10，类型为int的数组
	var a [10]int
	// goroutine起1000个,系统到底起了多少个线程 linux 下top可以查看
	// 系统起了7个线程，其中4个物理线程在运行，几个物理线程在运行那是由cpu核数决定 由此可见者1000个goroutine协程被调度器分配到了7个线程中
	for i := 0; i < 1000; i++ {
		// 创建一个goroutine 非抢占式协程
		// 如果没由go关键字，就是调用执行下面这个func 死循环不断打印...0
		// 加上go就不是调用，而是并发的去执行这个func main主程序还在往下跑，并发的开了一个func，开出来的函数里面不断的去执行响应逻辑
		go func(n int) { // 如果不传参数会 race condition 数据访问冲突 go run -race goroutine
			// 死循环
			for {
				// print是一个io操作，io是一个抢占式的打印的时候会导致协程的切换，所以打印顺序不一样
				fmt.Println("hello from goroutine n is ", n)

				// 在一个协程，不做协程切换就会被这个协程抢掉
				// 一个协程里，交不出控制权。它就死在里面了 运行会死机
				//a[n]++ //writer data
				//手动的让协程交出控制权
				//runtime.Gosched()
			}
		}(i)
	}
	// 让程序等待1毫秒， 以便让go 函数体内的东西能打印出来，要不然外出循环执行太快，会退出程序
	time.Sleep(time.Millisecond)
	//time.Sleep(time.Minute)
	// read data
	fmt.Println(a)
}
